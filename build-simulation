#!/usr/bin/env ruby
#
# Place this in a directory containing a Dockerfile and run it:
#
#     $ build-simulation <project-name> key1=value1 key2=value2
#
# Note: An docker image should already exist with the same name as the project.
#
# Example:
#
#     ./build-simulation yogurtbundle GEMFILE_CONTENTS='"$(cat Gemfile)"' LOCKFILE_CONTENTS='"$(cat Gemfile.lock)"'
require "securerandom"
require "digest"
require "fileutils"

project_name = ARGV[0]
args = ARGV[1..-1].sort

build_id = Digest::SHA256.hexdigest(project_name+args.join)
build_path = "/data/builds/#{project_name}"

latest_build_link = build_path + "/latest"
tmp_build_path    = build_path + "/pending/#{build_id}"
ready_build_path  = build_path + "/ready/#{build_id}"

abort("Build is in progress...") if File.exist?(tmp_build_path)

puts "Scheduling build for #{project_name} with id=#{build_id}"

# btrfs clone
cmd = "btrfs subvolume snapshot #{latest_build_link} #{tmp_build_path}"
res = Kernel.system(cmd)
# TODO: think about bootstrapping process here
if !res
        cmd = "btrfs subvolume create #{tmp_build_path} && mkdir -p #{tmp_build_path}/data/tmp #{tmp_build_path}/data/artifacts"
        res = Kernel.system(cmd)
        abort("Error executing #{cmd}") if !res
end

# prepare docker command to run and run it
cmd = "docker run --mount type=bind,source=#{tmp_build_path}/data,target=/data "
args.each do |a|
  cmd << "-e #{a} "
end
cmd << project_name

res = Kernel.system(cmd)
abort("Error executing #{cmd}") if !res

# move to ready
res = Kernel.system("mv #{tmp_build_path} #{ready_build_path}")
abort("Error executing #{cmd}") if !res

# symlink result to latest
# unfortunately, we have to remove the path first
FileUtils.safe_unlink(latest_build_link)
cmd = "ln -sf #{ready_build_path} #{latest_build_link}"
res = Kernel.system(cmd)
abort("Error executing #{cmd}") if !res
