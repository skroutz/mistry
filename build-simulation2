#!/usr/bin/env ruby
#
# Place this in a directory containing a Dockerfile and run it:
#
#     $ build-simulation <project-name> key1=value1 key2=value2
#
# Note: An docker image should already exist with the same name as the project.
#
# Example:
#
# GROUP="skroutz" ./build-simulation yogurtbundle GEMFILE_CONTENTS='"$(cat Gemfile)"' LOCKFILE_CONTENTS='"$(cat Gemfile.lock)"'
require "securerandom"
require "digest"
require "fileutils"

def btrfs_clone(build_link, tmp_build_path)
  cmd = "btrfs subvolume snapshot #{build_link} #{tmp_build_path}"
  res = Kernel.system(cmd)
  # TODO: think about bootstrapping process here
  if !res
    cmd = "btrfs subvolume create #{tmp_build_path} && mkdir -p #{tmp_build_path}/data/cache #{tmp_build_path}/data/artifacts"
    res = Kernel.system(cmd)
    abort("Error executing #{cmd}") if !res
  end
end

def symlink(ready_build_path, build_link)
  FileUtils.safe_unlink(build_link)
  cmd = "ln -sf #{ready_build_path} #{build_link}"
  res = Kernel.system(cmd)
  abort("Error executing #{cmd}") if !res
end

project_name = ARGV[0]
group = ENV['GROUP']
args = ARGV[1..-1].sort

build_id = Digest::SHA256.hexdigest(project_name + group.to_s + args.join)
build_path = "/data/builds/#{project_name}"

latest_build_link = build_path + "/latest"
group_build_link  = build_path + "/#{group}"
tmp_build_path    = build_path + "/pending/#{build_id}"
ready_build_path  = build_path + "/ready/#{build_id}"

abort("Build is in progress...") if File.exist?(tmp_build_path)

puts "Scheduling build for #{project_name} with id=#{build_id}"

if group.nil?
  btrfs_clone(latest_build_link, tmp_build_path)
else
  btrfs_clone(group_build_link, tmp_build_path)
end

# prepare docker command to run and run it
cmd = "docker run --mount type=bind,source=#{tmp_build_path}/data,target=/data "
args.each do |a|
  cmd << "-e #{a} "
end
cmd << project_name
7
